---
eip: 5450
title: EOF - Stack Validation
description: Deploy-time validation of stack usage for EOF functions.
author: Andrei Maiboroda (@gumb0), PaweÅ‚ Bylica (@chfast), Alex Beregszaszi (@axic), Danno Ferrin (@shemnon)
discussions-to: https://ethereum-magicians.org/t/eip-5450-eof-stack-validation/10410
status: Draft
type: Standards Track
category: Core
created: 2022-08-12
requires: 3540, 3670, 4200, 4750
---

## Abstract

Introduce extended validation of code sections to guarantee that stack underflow cannot happen during execution of validated contracts.

## Motivation

Currently existing EVM implementations perform a number of validity checks for each executed instruction, such as check for stack overflow/underflow, sufficient gas, etc. This change aims to minimize the number of such checks required at run-time, by verifying at deploy-time that no exceptional conditions can happen, and preventing to deploy the code where it could happen.

In particular, this extended code validation eliminates the need for EVM stack underflow checks done for every executed instruction. It also prevents deploying code that can be statically proven to require more than 1024 stack items, however it may still be possible to exceed that limit in some cases, and thus overflow checks cannot be fully eliminated.

The guarantees created by these validation rules also improves the feasabiliy of Ahead-Of-Time and Just-In-Time compilation of EVM code. Single pass transpilation passes can be safely executed with the code validation and advanced stack/register handling can be applied with the stack height validaitons. While not as impactful to a mainnet validator node that is bound mostly by storage state sizes, these can signignificantly speed up witness validation and other non-mainnet use cases.

## Specification

### Code validation

*Remark:* We rely on the notions of *operand stack* (FIXME) and *type section* as defined by [EIP-4750](./eip-4750.md).

Each code section is validated independently.

#### Instructions validation

In the first validation phase instructions are inspected independently to check if their opcodes and immediate data are valid.
This effectively replaced code validation in EIP-3670, EIP-4200 and EIP-4750.

A list of code length is created to collect purpose of each byte in the code: *data*, *jump target* or *other*.
Initially, all positions are marked as *other*.

For each instruction:

1. Check if opcode is defined.
2. If instruction has immediate data:
   1. Check if all immediate bytes are present in the code (code does not end in the middle of instruction).
   2. Check if none of the immediate bytes are marked as *jump target*.
   3. Mark all immediate bytes as *data*.
3. If instruction is function call (`CALLF`):
   1. Parse immediate bytes to get *target function index*.
   2. Check if *target function index* does not exceed the number of entries in the *type section*.
4. If instruction is static jump (`RJUMP`, `RJUMPI`)
   1. Parse immediate bytes to get *target relative offset*.
   2. Compute *target offset*.
   3. Check if *target offset* is within the code.
   4. Check if *target offset* is not marked as *data*.
   5. Mark *target offset* as *jump target*.
5. If the prior instruction was a terminal instruction
   1. Check that the current instruction is marked as a *jump target*

If any of the checks fails the validation fails.

The time and memory complexity if this pass is *O(len(code))*.

#### Operand stack validation

In the second validation phase data-flow (TODO: or control-flow) analysis is performed on the code.
For each instruction in the code the operand stack height is recorded.
The first instruction has the recorded stack height equal to the number of inputs to the function matching the code.

The instructions are processed in-order until there are no more instructions.

1. Determine the effect the instruction has on the operand stack:
   1. Check if the recorded stack height satisfies the instruction requirements.
      (Specifically for `RETF` instruction the recorded stack height must be exactly the number of outputs of the function matching the code).
   2. Compute new stack height after the instruction execution.
2. Determine the list of successor instructions than can follow the current instructions:
   1. The next instruction for all instructions other than terminating instructions and unconditional jump.
   2. The target of a conditional or unconditional jump.
3. For each successor instruction:
   1. If the instruction does not have stack height recorded record the instruction stack height as the value computed in 1.2.
   2. Otherwise, check if the recorded stack height equals the value computed in 1.2.
4. Determine the function maximum operand stack height:
   1. Compute the maximum stack height as the maximum of all recorded stack heights.
   2. Check if the maximum stack height does not exceed the limit (1024).

The time and memory complexity if this pass is *O(len(code))*. Each instruction is visited at most once. Because the analysis is in code order this can be combined with instruction validation, but is presented separately for clarity.

### Execution

Given the deploy-time validation guarantees, an EVM implementation is not required anymore to have run-time stack underflow check for each executed instruction.

Stack overflow check, on the other hand, is still required at run-time, because function execution can start at arbitrary (i.e. known only at run-time) stack height at `CALLF` instruction of a caller (i.e. each execution can be in arbitrary inner call frame). Validation algorithm examines only stack height changes relative to starting stack height of the function.


## Rationale

### Stack overflow check only in CALLF

In the current proposal stack overflow checks are unchanged (i.e. are done for every instruction). However, we can provide more efficient variant where stack overflow check is performed only in `CALLF` instruction and uses called function's `max_stack_height` information for this. This decreases flexibility of an EVM program because `max_stack_height` corresponds to the worst-case control-flow path in the function.
Moreover, the `max_stack_height` computed during validation must be stored alongside the code, likely in the type section header.

### Clean stack upon termination

It is currently required that the operand stack is empty (in the current function context) after the `RETF` instruction.
Otherwise, the `RETF` semantic would be more complicated. For `n` function outputs and `s` the stack height at `RETF` the EVM must erase `s-n` non-top stack items and move the `n` stack items to the place of erased ones. Cost of such operation may be relatively cheap but is not constant.
However, lifting the requirement and modifying the `RETF` semantic as described above is backward
compatible and can be easily introduced in the future.

### Forward Referenced Jump Destinations

The requirement that all instructons after a terminal instruction be the target of at least one forward referenced jump is present to enable two features:

1. Forces dead code elimination.  Any code that can be reached from the first instruction will be marked with a stack height. Any code run that has only "backward references" can be moved by compilers to be after any of the other code runs referenceing it that has been referenced by and that are referenced already examined code.  If no such code run exists then we can conclude that it is unreachable from the first instruction and is dead code.
2. This eliminates the need for a worklist driven loop in stack validation, as we can ensure that each operation encountered in linear order has a stack height, ether from being a following a non-terminal instruction or being a jump target.  The sole exception is the first instruction which receives its height from the type section.

## Backwards Compatibility

This change requires a "network upgrade", since it modifies consensus rules.

It poses no risk to backwards compatibility, as it is introduced only for EOF1 contracts, for which deploying undefined instructions is not allowed, therefore there are no existing contracts using these instructions. The new instructions are not introduced for legacy bytecode (code which is not EOF formatted).

## Reference Implementation

```python
# Returns maximum stack height required by function execution frame
# (not including frames of internal calls)
# Raises ValidateException if code is invalid.
def validate_function_2pass(func_id: int, code: bytes, types: list[FunctionType]) -> int:

   # Instructions validation.
   code_map = [CodeMark.OTHER] * len(code)
   i = 0
   while i < len(code):
      opcode = code[i]
      if opcode not in valid_opcodes:
         raise ValidationException("undefined instruction")
      imm_len = TABLE[opcode].immediate_size
      if i + imm_len >= len(code):
         raise ValidationException("truncated immediate")
      for j in range(imm_len):
         if code_map[i + 1 + j] == CodeMark.JUMP_TARGET:
            raise ValidationException("invalid jump target")
         code_map[i + 1 + j] = CodeMark.DATA

      if opcode == OP_CALLF:
         target_func_idx = int.from_bytes(code[i + 1:i + 3], byteorder="big", signed=False)
         if target_func_idx >= len(types):
            raise ValidationException("invalid target function index")
      elif opcode in (OP_RJUMP, OP_RJUMPI):
         target_relative_offset = int.from_bytes(code[i + 1:i + 3], byteorder="big", signed=True)
         target_relative_offset = i + 3 + target_relative_offset
         if target_relative_offset < 0:
            raise ValidationException("invalid jump target")
         elif target_relative_offset >= len(code):
            raise ValidationException("invalid jump target")
         elif code_map[target_relative_offset] == CodeMark.DATA:
            raise ValidationException("invalid jump target")
         code_map[target_relative_offset] = CodeMark.JUMP_TARGET

      i += 1 + imm_len

   # Does not reflect forward-referenced jump optimizations
   # Operand stack validation
   stack_heights = [-1] * len(code)
   stack_heights[0] = types[func_id].inputs
   worklist = [0]
   while worklist:
      i = worklist.pop(0)

      opcode = code[i]
      stack_height_required = TABLE[opcode].stack_height_required
      stack_height_change = TABLE[opcode].stack_height_change
      if opcode == OP_CALLF:
         fid = int.from_bytes(code[i + 1:i + 3], byteorder="big", signed=True)
         stack_height_required = types[fid].inputs
         stack_height_change = types[fid].outputs - stack_height_required

      stack_height = stack_heights[i]
      assert stack_height != -1
      if stack_height < stack_height_required:
         raise ValidationException("stack underflow")

      successors = []
      if opcode != OP_RJUMP and not TABLE[opcode].is_terminating:
         next = i + TABLE[opcode].immediate_size + 1
         if next >= len(code):
            raise ValidationException("execution not terminated")
         successors.append(next)
      if opcode in (OP_RJUMP, OP_RJUMPI):
         target_relative_offset = int.from_bytes(code[i + 1:i + 3], byteorder="big", signed=True)
         target_offset = i + target_relative_offset + 3
         successors.append(target_offset)

      stack_height = stack_height + stack_height_change

      for s in successors:
         if stack_heights[s] == -1:  # visited first time
            stack_heights[s] = stack_height
            worklist.append(s)
         elif stack_heights[s] != stack_height:
            raise ValidationException("stack height mismatch for different paths")

      if opcode == OP_RETF and stack_height != types[func_id].outputs:
         raise ValidationException("non-empty stack on terminating instruction")
      # if opcode != OP_RETF and TABLE[opcode].is_terminating and stack_height != 0:
      #     raise ValidationException("non-empty stack on terminating instruction")

   max_stack_height = max(stack_heights)
   if max_stack_height >= 1023:
      raise ValidationException("max stack above limit")
   return max_stack_height
```

## Test Cases

* Successful
   * Multiple forward jumps to the same destination, with matching stack heights
* Failures
   * Multiple forward jumps to the same destination, with differing stack heights (fails)
   * Dead code, with no jump references
   * Dead code, with backward jump reference

## Security Considerations

Needs discussion.

## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
